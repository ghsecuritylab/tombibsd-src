#	$NetBSD$

#
# Backup disklabels of available disks
#

	# migrate old disklabels
for file in $(ls -1d $backup_dir/$backup_dir/disklabel.* \
    $backup_dir/disklabel.* 2>/dev/null); do
	migrate_file "$file" "$work_dir/${file##*/}"
done

	# generate list of old disklabels, fdisks & wedges,
	# and remove them
ls -1d $work_dir/disklabel.* $work_dir/fdisk.* $work_dir/wedges.* \
    2>/dev/null |
    egrep -v '\.(backup|current)(,v)?$' > $LABELS
xargs rm < $LABELS

disks="$(iostat -x | cut -f 1 -d ' ' )"

	# generate disklabels of all disks excluding:	cd fd md dk st
	# nfs and "device" (the header of iostat)
for i in $disks; do
	case $i in
	[cfm]d[0-9]*|dk[0-9]*|st[0-9]*|nfs|device) 
		;;
	*)
		if disklabel $i > /dev/null 1>&2; then
			disklabel $i > "$work_dir/disklabel.$i"
		fi
		;;
	esac
done

	# if fdisk is available, generate fdisks for:	ed ld sd wd
if [ -x /sbin/fdisk ]; then
	for i in $disks; do
		case $i in
		[elsw]d[0-9]*)
			/sbin/fdisk $i > "$work_dir/fdisk.$i" \
			    2>/dev/null
			;;
		esac
	done
fi

	# if dkctl is available, generate dkctl listwedges
	# for:	ed ld sd wd cgd ofdisk ra rl raid
if [ -x /sbin/dkctl ]; then
	for i in $disks; do
		case $i in
		[elsw]d[0-9]*|cgd[0-9]*|ofdisk[0-9]*|r[al][0-9]*|raid[0-9]*)
			if /sbin/dkctl $i listwedges -qe; then
				/sbin/dkctl $i listwedges \
				    > "$work_dir/wedges.$i" 2>/dev/null
			fi
			;;
		esac
	done
fi

	# append list of new disklabels, fdisks and wedges
ls -1d $work_dir/disklabel.* $work_dir/fdisk.* $work_dir/wedges.* \
    2>/dev/null |
    egrep -v '\.(backup|current)(,v)?$' >> $LABELS
CHANGELIST="$LABELS $CHANGELIST"
