#	$NetBSD$

# XXX: the sense of permit_star is reversed; the code works as
# implemented, but usage needs to be negated.
checkyesno check_passwd_permit_star && permit_star=0 || permit_star=1
checkyesno check_passwd_permit_nonalpha \
	 && permit_nonalpha=1 || permit_nonalpha=0

awk -v "len=$max_loginlen" \
    -v "nowarn_shells_list=$check_passwd_nowarn_shells" \
    -v "nowarn_users_list=$check_passwd_nowarn_users" \
    -v "permit_star=$permit_star" \
    -v "permit_nonalpha=$permit_nonalpha" \
'
BEGIN {
	while ( getline < "/etc/shells" > 0 ) {
		if ($0 ~ /^\#/ || $0 ~ /^$/ )
			continue;
		shells[$1]++;
	}
	split(nowarn_shells_list, a);
	for (i in a) nowarn_shells[a[i]]++;
	split(nowarn_users_list, a);
	for (i in a) nowarn_users[a[i]]++;
	uid0_users_list="root toor"
	split(uid0_users_list, a);
	for (i in a) uid0_users[a[i]]++;
	FS=":";
}

{
	if ($0 ~ /^[	 ]*$/) {
		printf "Line %d is a blank line.\n", NR;
		next;
	}

	# NIS compat entry?
	compatline = $1 ~ "^[\\+-]";
	if (compatline) {
		if ($1 == "+" && NF == 1) {
			next;
		}
		sub("^.", "", $1);
	}
	if (NF != 10)
		printf "Line %d has the wrong number of fields.\n", NR;
	if (compatline)  {
		if ($3 == 0)
		    printf "Line %d includes entries with uid 0.\n",
		        NR;
		if ($1 == "")
		    next;
	}
	if (!permit_nonalpha &&
	    $1 !~ /^[_A-Za-z0-9]([-A-Za-z0-9_.]*[A-Za-z0-9])*$/)
		printf "Login %s has non-alphanumeric characters.\n",
		    $1;
	if (length($1) > len)
		printf "Login %s has more than "len" characters.\n",
		    $1;
	if ($2 == "" && !compatline && !nowarn_users[$1])
		    printf "Login %s has no password.\n", $1;
	if (!nowarn_shells[$10] && !nowarn_users[$1]) {
	    if (length($2) != 13 &&
		length($2) != 20 &&
		$2 !~ /^\$1/ &&
		$2 !~ /^\$2/ &&
		$2 !~ /^\$sha1/ &&
		$2 != "" &&
		(permit_star || $2 != "*") &&
		$2 !~ /^\*[A-z-]+$/ &&
		$1 != "toor") {
		    if ($10 == "" || shells[$10])
			printf "Login %s is off but still has "\
			  "a valid shell (%s)\n", $1, $10;
	    } else if (compatline && $10 == "") {
		    # nothing
	    } else if (! shells[$10])
		    printf "Login %s does not have a valid "\
		    "shell (%s)\n", $1, $10;
	}
	if ($3 == 0 && !uid0_users[$1] && !nowarn_users[$1])
		printf "Login %s has a user id of 0.\n", $1;
	if ($3 != "" && $3 < 0)
		printf "Login %s has a negative user id.\n", $1;
	if ($4 != "" && $4 < 0)
		printf "Login %s has a negative group id.\n", $1;
}' < $MP > $OUTPUT
if [ -s $OUTPUT ] ; then
	printf "\nChecking the $MP file:\n"
	cat $OUTPUT
fi

awk -F: '{ print $1 }' $MP | sort | uniq -d > $OUTPUT
if [ -s $OUTPUT ] ; then
	printf "\n$MP has duplicate user names.\n"
	column $OUTPUT
fi

awk -v "permit_dups_list=$check_passwd_permit_dups" \
'
BEGIN {
	split(permit_dups_list, a);
	for (i in a) permit_dups[a[i]]++;
}
{
	if (!permit_dups[$1])
		print $2;
}' < $MPBYUID | uniq -d > $TMP2
if [ -s $TMP2 ] ; then
	printf "\n$MP has duplicate user ids.\n"
	while read uid; do
		grep -w $uid $MPBYUID
	done < $TMP2 | column
fi
